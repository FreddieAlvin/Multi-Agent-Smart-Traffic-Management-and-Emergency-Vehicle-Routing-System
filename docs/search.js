window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "agents", "modulename": "agents", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agents.emergency_vehicle", "modulename": "agents.emergency_vehicle", "kind": "module", "doc": "<p>Emergency vehicle agent module.</p>\n\n<p>This module defines the EmergencyVehicleAgent, a SPADE autonomous agent that\nimplements intelligent emergency response behavior in the simulation.</p>\n\n<p>Key features:\n    - A* routing with reduced congestion penalties (faster navigation)\n    - Avoidance of blocked edges reported by EventManager\n    - Automatic switching between \"to_hospital\" and \"to_random\" phases\n    - Traffic-light priority negotiation\n    - Integration with the Metrics system to track emergency response time\n    - Incident gossip handling (merging distributed incident information)</p>\n\n<p>This agent continuously cycles:\n    hospital \u2192 random incident \u2192 hospital \u2192 random incident \u2192 ...</p>\n"}, {"fullname": "agents.emergency_vehicle.manhattan", "modulename": "agents.emergency_vehicle", "qualname": "manhattan", "kind": "function", "doc": "<p>Return the Manhattan distance between two (x, y) points.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agents.emergency_vehicle.EmergencyVehicleAgent", "modulename": "agents.emergency_vehicle", "qualname": "EmergencyVehicleAgent", "kind": "class", "doc": "<p>Autonomous emergency vehicle with priority-aware routing.</p>\n\n<p>This agent simulates an ambulance or emergency responder. It travels between\nhospitals and random points in the city using A* pathfinding, dynamically\nadapting to congestion and incidents.</p>\n\n<p>Features:\n    - Avoids blocked edges reported by EventManager.\n    - Negotiates priority with traffic lights.\n    - Uses congestion-aware edge weights.\n    - Sends/receives incident gossip updates.\n    - Triggers metric collection for emergency response time.</p>\n\n<p>Attributes:\n    label (str): Human-readable name.\n    city (CityEnvironment): Shared simulation environment.\n    shared (dict): Shared position dictionary for visualization.\n    position (tuple): Current (x, y) grid coordinate.\n    fixed_dest (tuple | None): Optional dedicated hospital node.\n    goal (tuple | None): Current navigation target.\n    path (list[tuple]): Planned A* route.\n    steps_since_plan (int): Counter for replan detection.\n    pause_at_goal (float): Delay after reaching an endpoint.\n    phase (str): Either \"to_hospital\" or \"to_random\".</p>\n", "bases": "spade.agent.Agent"}, {"fullname": "agents.emergency_vehicle.EmergencyVehicleAgent.__init__", "modulename": "agents.emergency_vehicle", "qualname": "EmergencyVehicleAgent.__init__", "kind": "function", "doc": "<p>Initialize the emergency vehicle agent.</p>\n\n<p>Args:\n    jid (str): Agent JID.\n    password (str): Authentication password.\n    name (str): Human-readable label (e.g. \"Ambulance 1\").\n    city_env (CityEnvironment): Reference to the city environment.\n    shared (dict | None): Shared visualization state.\n    fixed_dest (tuple | None): Station / hospital node. If None,\n        any hospital is used as a base.\n    pause_at_goal (float): Pause duration at each target.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">jid</span>,</span><span class=\"param\">\t<span class=\"n\">password</span>,</span><span class=\"param\">\t<span class=\"n\">name</span>,</span><span class=\"param\">\t<span class=\"n\">city_env</span>,</span><span class=\"param\">\t<span class=\"n\">shared</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fixed_dest</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">pause_at_goal</span><span class=\"o\">=</span><span class=\"mf\">2.0</span></span>)</span>"}, {"fullname": "agents.emergency_vehicle.EmergencyVehicleAgent.label", "modulename": "agents.emergency_vehicle", "qualname": "EmergencyVehicleAgent.label", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.emergency_vehicle.EmergencyVehicleAgent.city", "modulename": "agents.emergency_vehicle", "qualname": "EmergencyVehicleAgent.city", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.emergency_vehicle.EmergencyVehicleAgent.shared", "modulename": "agents.emergency_vehicle", "qualname": "EmergencyVehicleAgent.shared", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.emergency_vehicle.EmergencyVehicleAgent.fixed_dest", "modulename": "agents.emergency_vehicle", "qualname": "EmergencyVehicleAgent.fixed_dest", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.emergency_vehicle.EmergencyVehicleAgent.goal", "modulename": "agents.emergency_vehicle", "qualname": "EmergencyVehicleAgent.goal", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.emergency_vehicle.EmergencyVehicleAgent.path", "modulename": "agents.emergency_vehicle", "qualname": "EmergencyVehicleAgent.path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.emergency_vehicle.EmergencyVehicleAgent.steps_since_plan", "modulename": "agents.emergency_vehicle", "qualname": "EmergencyVehicleAgent.steps_since_plan", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.emergency_vehicle.EmergencyVehicleAgent.pause_at_goal", "modulename": "agents.emergency_vehicle", "qualname": "EmergencyVehicleAgent.pause_at_goal", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.emergency_vehicle.EmergencyVehicleAgent.EmergencyBehaviour", "modulename": "agents.emergency_vehicle", "qualname": "EmergencyVehicleAgent.EmergencyBehaviour", "kind": "class", "doc": "<p>Periodic behaviour controlling movement, replanning, incident gossip\ningestion, priority negotiation, emergency timing, and collision\navoidance for the emergency vehicle.</p>\n", "bases": "spade.behaviour.PeriodicBehaviour"}, {"fullname": "agents.emergency_vehicle.EmergencyVehicleAgent.EmergencyBehaviour.on_start", "modulename": "agents.emergency_vehicle", "qualname": "EmergencyVehicleAgent.EmergencyBehaviour.on_start", "kind": "function", "doc": "<p>Executed once when the behaviour begins.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "agents.emergency_vehicle.EmergencyVehicleAgent.EmergencyBehaviour.run", "modulename": "agents.emergency_vehicle", "qualname": "EmergencyVehicleAgent.EmergencyBehaviour.run", "kind": "function", "doc": "<p>Main loop executed periodically:\n    - read incident gossip\n    - perform arrival checks and phase switching\n    - plan new routes when needed\n    - step along A* path\n    - manage collisions\n    - request priority from nearest traffic light\n    - log emergency start/end for metrics</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "agents.emergency_vehicle.EmergencyVehicleAgent.setup", "modulename": "agents.emergency_vehicle", "qualname": "EmergencyVehicleAgent.setup", "kind": "function", "doc": "<p>Attach and start the EmergencyBehaviour on agent startup.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "agents.incident_reporter", "modulename": "agents.incident_reporter", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agents.incident_reporter.IncidentReporterAgent", "modulename": "agents.incident_reporter", "qualname": "IncidentReporterAgent", "kind": "class", "doc": "<p>Agent responsible for generating and broadcasting temporary incidents\n(roadblocks) to all system agents. It periodically selects a random\nedge in the road network, marks it as blocked, and gossips this update\nto vehicles and traffic lights.</p>\n\n<p>Responsibilities:\n    \u2022 Randomly inject temporary roadblock events into the environment.\n    \u2022 Update the shared EventManager so that pathfinding avoids the edge.\n    \u2022 Broadcast incident gossip in JSON format to all known agents.\n    \u2022 Enable decentralized awareness of accidents across the system.</p>\n\n<p>Parameters:\n    jid (str): Jabber/XMPP identifier for the SPADE agent.\n    password (str): SPADE agent password.\n    city (CityEnvironment): Shared environment containing the road graph\n        and agent registries.\n    event_manager (EventManager): Component storing incident states and\n        providing lookup utilities.</p>\n", "bases": "spade.agent.Agent"}, {"fullname": "agents.incident_reporter.IncidentReporterAgent.__init__", "modulename": "agents.incident_reporter", "qualname": "IncidentReporterAgent.__init__", "kind": "function", "doc": "<p>Creates an agent</p>\n\n<p>Args:\n  jid (str): The identifier of the agent in the form username@server\n  password (str): The password to connect to the server\n  verify_security (bool): Weather to verify or not the SSL certificates</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">jid</span>, </span><span class=\"param\"><span class=\"n\">password</span>, </span><span class=\"param\"><span class=\"n\">city</span>, </span><span class=\"param\"><span class=\"n\">event_manager</span></span>)</span>"}, {"fullname": "agents.incident_reporter.IncidentReporterAgent.city", "modulename": "agents.incident_reporter", "qualname": "IncidentReporterAgent.city", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.incident_reporter.IncidentReporterAgent.event_manager", "modulename": "agents.incident_reporter", "qualname": "IncidentReporterAgent.event_manager", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.incident_reporter.IncidentReporterAgent.BroadcastBehaviour", "modulename": "agents.incident_reporter", "qualname": "IncidentReporterAgent.BroadcastBehaviour", "kind": "class", "doc": "<p>Periodic behaviour that creates and broadcasts temporary incidents.\nEvery cycle, with a configurable probability, a random road segment\nis selected and marked as blocked for a short duration.</p>\n\n<p>Responsibilities:\n    \u2022 Select a random edge from the city's road graph.\n    \u2022 Create a temporary incident using EventManager.\n    \u2022 Construct an incident gossip payload in JSON format.\n    \u2022 Broadcast the update to all vehicles and traffic lights.</p>\n\n<p>Message Format:\n    {\n        \"type\": \"incident_gossip\",\n        \"hop_ttl\": <remaining hops>,\n        \"payload\": {\n            \"edge\": [[x1, y1], [x2, y2]],\n            \"severity\": <severity value>,\n            \"expires_at\": <unix timestamp>\n        }\n    }</p>\n", "bases": "spade.behaviour.PeriodicBehaviour"}, {"fullname": "agents.incident_reporter.IncidentReporterAgent.BroadcastBehaviour.run", "modulename": "agents.incident_reporter", "qualname": "IncidentReporterAgent.BroadcastBehaviour.run", "kind": "function", "doc": "<p>Body of the behaviour.\nTo be implemented by user.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "agents.incident_reporter.IncidentReporterAgent.setup", "modulename": "agents.incident_reporter", "qualname": "IncidentReporterAgent.setup", "kind": "function", "doc": "<p>Initializes the Incident Reporter and starts its periodic broadcast\nbehaviour. This behaviour runs every 8 seconds and may generate new\nincidents depending on random chance.</p>\n\n<p>Responsibilities:\n    \u2022 Register BroadcastBehaviour with SPADE runtime.\n    \u2022 Print startup diagnostics to console.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "agents.traffic_lights", "modulename": "agents.traffic_lights", "kind": "module", "doc": "<p>traffic_lights.py</p>\n\n<p>Implements the TrafficLightAgent, a SPADE agent that simulates an adaptive\ntraffic light in a grid-based smart-city environment.</p>\n\n<p>Each traffic light:</p>\n\n<ul>\n<li>Alternates between two phases:\nPhase 0: North/South movement allowed\nPhase 1: East/West movement allowed</li>\n<li>Adapts its phase duration based on local road congestion</li>\n<li>Responds to two types of requests:\n<ul>\n<li>priority_request (emergency vehicles)</li>\n<li>passage_request (regular vehicles)</li>\n</ul></li>\n<li>Integrates with the EventManager to block edges affected by incidents</li>\n<li>Follows a Contract Net\u2013style reply semantics (accept/reject proposals)</li>\n</ul>\n\n<p>This file defines:\n    direction() \u2192 Infer direction of movement from grid coordinates.\n    TrafficLightAgent \u2192 SPADE agent controlling a single traffic light.</p>\n"}, {"fullname": "agents.traffic_lights.ALLOWED_BY_PHASE", "modulename": "agents.traffic_lights", "qualname": "ALLOWED_BY_PHASE", "kind": "variable", "doc": "<p></p>\n", "default_value": "{0: {&#x27;S&#x27;, &#x27;N&#x27;}, 1: {&#x27;W&#x27;, &#x27;E&#x27;}}"}, {"fullname": "agents.traffic_lights.PHASE_DURATION", "modulename": "agents.traffic_lights", "qualname": "PHASE_DURATION", "kind": "variable", "doc": "<p></p>\n", "default_value": "5.0"}, {"fullname": "agents.traffic_lights.direction", "modulename": "agents.traffic_lights", "qualname": "direction", "kind": "function", "doc": "<p>Infer movement direction between two grid coordinates.</p>\n\n<p>Args:\n    from_pos (tuple[int, int]): Current position (x, y).\n    to_pos (tuple[int, int]): Next position (x, y).</p>\n\n<p>Returns:\n    str | None:\n        \"N\", \"S\", \"E\", or \"W\" depending on movement.\n        None if movement is diagonal or zero.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">from_pos</span>, </span><span class=\"param\"><span class=\"n\">to_pos</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agents.traffic_lights.TrafficLightAgent", "modulename": "agents.traffic_lights", "qualname": "TrafficLightAgent", "kind": "class", "doc": "<p>Traffic light controller agent.</p>\n\n<p>This agent autonomously alternates between NS and EW phases, adjusts the\nduration of each phase according to observed traffic density, and processes\nvehicle passage requests.</p>\n\n<p>Attributes:\n    city (CityEnvironment): The global environment object.\n    shared (dict): Shared state dictionary for visualization.\n    position (tuple[int, int] | None): Grid coordinate of the light.\n    phase (int): Current phase (0=NS, 1=EW).\n    phase_duration (float): Adaptive duration of the current phase.\n    _last_switch (float): Time of last phase toggle.</p>\n", "bases": "spade.agent.Agent"}, {"fullname": "agents.traffic_lights.TrafficLightAgent.__init__", "modulename": "agents.traffic_lights", "qualname": "TrafficLightAgent.__init__", "kind": "function", "doc": "<p>Creates an agent</p>\n\n<p>Args:\n  jid (str): The identifier of the agent in the form username@server\n  password (str): The password to connect to the server\n  verify_security (bool): Weather to verify or not the SSL certificates</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">jid</span>, </span><span class=\"param\"><span class=\"n\">password</span>, </span><span class=\"param\"><span class=\"n\">city_env</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">shared</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "agents.traffic_lights.TrafficLightAgent.city", "modulename": "agents.traffic_lights", "qualname": "TrafficLightAgent.city", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.traffic_lights.TrafficLightAgent.shared", "modulename": "agents.traffic_lights", "qualname": "TrafficLightAgent.shared", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.traffic_lights.TrafficLightAgent.position", "modulename": "agents.traffic_lights", "qualname": "TrafficLightAgent.position", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.traffic_lights.TrafficLightAgent.phase_duration", "modulename": "agents.traffic_lights", "qualname": "TrafficLightAgent.phase_duration", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.traffic_lights.TrafficLightAgent.phase", "modulename": "agents.traffic_lights", "qualname": "TrafficLightAgent.phase", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.traffic_lights.TrafficLightAgent.LightBehaviour", "modulename": "agents.traffic_lights", "qualname": "TrafficLightAgent.LightBehaviour", "kind": "class", "doc": "<p>Cyclic behaviour controlling the traffic-light loop.</p>\n\n<p>Responsibilities:\n    1. Adapt phase duration using local traffic density.\n    2. Toggle phase when time expires.\n    3. Process passage requests (regular or emergency).\n    4. Use Contract Net semantics for responses.</p>\n", "bases": "spade.behaviour.CyclicBehaviour"}, {"fullname": "agents.traffic_lights.TrafficLightAgent.LightBehaviour.on_start", "modulename": "agents.traffic_lights", "qualname": "TrafficLightAgent.LightBehaviour.on_start", "kind": "function", "doc": "<p>Initializes light phase and timestamp.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "agents.traffic_lights.TrafficLightAgent.LightBehaviour.run", "modulename": "agents.traffic_lights", "qualname": "TrafficLightAgent.LightBehaviour.run", "kind": "function", "doc": "<p>Main control loop executed repeatedly.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "agents.traffic_lights.TrafficLightAgent.setup", "modulename": "agents.traffic_lights", "qualname": "TrafficLightAgent.setup", "kind": "function", "doc": "<p>Initializes the traffic-light agent.</p>\n\n<p>Extracts its grid position from its JID (e.g., 'light_4_8@localhost'),\nsets initial timing parameters, and registers the behaviour loop.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "agents.vehicle", "modulename": "agents.vehicle", "kind": "module", "doc": "<p>ISIA - Introduction to Autonomous Intelligent Systems\nMulti-Agent Smart Traffic Management and Emergency Vehicle Routing System</p>\n\n<p>File:\n    agents/vehicle.py</p>\n\n<p>Description:\n    Defines the \"normal\" (non-priority) vehicle agent, responsible for:\n      - planning routes with A* on the city graph;\n      - avoiding blocked edges and nodes created by incidents;\n      - requesting passage at traffic lights using a Contract Net-like protocol;\n      - updating occupancy (congestion) and recording trip metrics;\n      - cooperating with the visualizer through the shared state.</p>\n\n<pre><code>This agent represents standard city traffic that coexists with emergency\nvehicles and dynamic events.\n</code></pre>\n"}, {"fullname": "agents.vehicle.USE_FILTERED_INCIDENTS", "modulename": "agents.vehicle", "qualname": "USE_FILTERED_INCIDENTS", "kind": "variable", "doc": "<p></p>\n", "default_value": "False"}, {"fullname": "agents.vehicle.manhattan", "modulename": "agents.vehicle", "qualname": "manhattan", "kind": "function", "doc": "<p>Compute Manhattan distance between two grid points.</p>\n\n<p>Args:\n    a (tuple[int, int]): First point (x, y).\n    b (tuple[int, int]): Second point (x, y).</p>\n\n<p>Returns:\n    int: |x1 - x2| + |y1 - y2|.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agents.vehicle.VehicleAgent", "modulename": "agents.vehicle", "qualname": "VehicleAgent", "kind": "class", "doc": "<p>Normal (non-emergency) vehicle agent.</p>\n\n<p>Responsibilities:</p>\n\n<ul>\n<li>Choose random, reasonably distant destinations.</li>\n<li>Plan routes using A*, combining:\n<ul>\n<li>base edge weight,</li>\n<li>congestion (occupancy) density,</li>\n<li>penalties due to incidents/roadblocks.</li>\n</ul></li>\n<li>Coordinate with traffic lights via a Contract Net-like protocol.</li>\n<li>Avoid collisions (never enter an occupied node).</li>\n<li>Update trip metrics (trip duration and replans).</li>\n<li>Publish current position to the shared viewer state.</li>\n</ul>\n", "bases": "spade.agent.Agent"}, {"fullname": "agents.vehicle.VehicleAgent.__init__", "modulename": "agents.vehicle", "qualname": "VehicleAgent.__init__", "kind": "function", "doc": "<p>Initialize the vehicle agent.</p>\n\n<p>Args:\n    jid (str): XMPP JID of the agent.\n    password (str): Agent password.\n    name (str): Human-friendly label (e.g., \"Vehicle 1\").\n    city_env (CityEnvironment): City environment containing the graph and services.\n    shared (dict | None): Shared-state dictionary used by the visualizer.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">jid</span>, </span><span class=\"param\"><span class=\"n\">password</span>, </span><span class=\"param\"><span class=\"n\">name</span>, </span><span class=\"param\"><span class=\"n\">city_env</span>, </span><span class=\"param\"><span class=\"n\">shared</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "agents.vehicle.VehicleAgent.label", "modulename": "agents.vehicle", "qualname": "VehicleAgent.label", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.vehicle.VehicleAgent.city", "modulename": "agents.vehicle", "qualname": "VehicleAgent.city", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.vehicle.VehicleAgent.shared", "modulename": "agents.vehicle", "qualname": "VehicleAgent.shared", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.vehicle.VehicleAgent.position", "modulename": "agents.vehicle", "qualname": "VehicleAgent.position", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.vehicle.VehicleAgent.goal", "modulename": "agents.vehicle", "qualname": "VehicleAgent.goal", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.vehicle.VehicleAgent.path", "modulename": "agents.vehicle", "qualname": "VehicleAgent.path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.vehicle.VehicleAgent.steps_since_plan", "modulename": "agents.vehicle", "qualname": "VehicleAgent.steps_since_plan", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.vehicle.VehicleAgent.replan_every", "modulename": "agents.vehicle", "qualname": "VehicleAgent.replan_every", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agents.vehicle.VehicleAgent.VehicleBehaviour", "modulename": "agents.vehicle", "qualname": "VehicleAgent.VehicleBehaviour", "kind": "class", "doc": "<p>Main periodic behaviour of the vehicle.</p>\n\n<p>Loop:</p>\n\n<ul>\n<li>Initial wait to avoid startup bursts.</li>\n<li>Destination arrival detection.</li>\n<li>Incident-triggered replanning.</li>\n<li>A* replanning when necessary.</li>\n<li>Contract-Net style negotiation with traffic lights.</li>\n<li>Collision avoidance.</li>\n<li>Occupancy + viewer updates.</li>\n</ul>\n", "bases": "spade.behaviour.PeriodicBehaviour"}, {"fullname": "agents.vehicle.VehicleAgent.VehicleBehaviour.on_start", "modulename": "agents.vehicle", "qualname": "VehicleAgent.VehicleBehaviour.on_start", "kind": "function", "doc": "<p>Executed once before the periodic loop begins.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "agents.vehicle.VehicleAgent.VehicleBehaviour.run", "modulename": "agents.vehicle", "qualname": "VehicleAgent.VehicleBehaviour.run", "kind": "function", "doc": "<p>Main loop implementing the agent life cycle.</p>\n\n<p>Handles:\n    - goal arrival,\n    - replanning logic,\n    - incident messages,\n    - traffic light coordination,\n    - collision avoidance,\n    - occupancy + viewer updates.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "agents.vehicle.VehicleAgent.setup", "modulename": "agents.vehicle", "qualname": "VehicleAgent.setup", "kind": "function", "doc": "<p>Setup method executed when the agent starts.</p>\n\n<p>Adds the periodic behaviour and prints the initial position.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "environment", "modulename": "environment", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "environment.city", "modulename": "environment.city", "kind": "module", "doc": "<p>city.py</p>\n\n<p>Definition of the grid-based city environment used by all agents.</p>\n\n<p>The CityEnvironment class:</p>\n\n<ul>\n<li>creates a rectangular grid as a NetworkX graph;</li>\n<li>attaches edge weights that can change with congestion;</li>\n<li>keeps track of traffic lights and hospitals;</li>\n<li>exposes helper methods to:\n<ul>\n<li>sample free nodes;</li>\n<li>compute average congestion;</li>\n<li>randomly spawn and remove temporary roadblocks.</li>\n</ul></li>\n</ul>\n"}, {"fullname": "environment.city.CityEnvironment", "modulename": "environment.city", "qualname": "CityEnvironment", "kind": "class", "doc": "<p>Grid city with dynamic edge weights, occupancy, and incidents.</p>\n\n<p>Attributes:\n    width:   Number of columns in the grid.\n    height:  Number of rows in the grid.\n    graph:   NetworkX graph representing the road network.\n    traffic_lights:\n        Map from light id (e.g. \"light_4_4\") to node coordinates.\n    hospitals:\n        Map from hospital id to node coordinates.\n    occupancy:\n        Occupancy helper that tracks how many vehicles use each edge.\n    event_manager:\n        EventManager that stores temporary incidents / roadblocks.\n    metrics:\n        Optional Metrics object, filled by main.py.\n    vehicle_jids:\n        List of JIDs for all vehicle agents (for broadcast if needed).</p>\n"}, {"fullname": "environment.city.CityEnvironment.__init__", "modulename": "environment.city", "qualname": "CityEnvironment.__init__", "kind": "function", "doc": "<p>Build a new grid city.</p>\n\n<p>Args:\n    width:  Grid width in cells.\n    height: Grid height in cells.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">width</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">20</span>, </span><span class=\"param\"><span class=\"n\">height</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">20</span></span>)</span>"}, {"fullname": "environment.city.CityEnvironment.width", "modulename": "environment.city", "qualname": "CityEnvironment.width", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.city.CityEnvironment.height", "modulename": "environment.city", "qualname": "CityEnvironment.height", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.city.CityEnvironment.graph", "modulename": "environment.city", "qualname": "CityEnvironment.graph", "kind": "variable", "doc": "<p></p>\n", "annotation": ": networkx.classes.graph.Graph"}, {"fullname": "environment.city.CityEnvironment.traffic_lights", "modulename": "environment.city", "qualname": "CityEnvironment.traffic_lights", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Dict[str, Tuple[int, int]]"}, {"fullname": "environment.city.CityEnvironment.hospitals", "modulename": "environment.city", "qualname": "CityEnvironment.hospitals", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Dict[str, Tuple[int, int]]"}, {"fullname": "environment.city.CityEnvironment.vehicle_jids", "modulename": "environment.city", "qualname": "CityEnvironment.vehicle_jids", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[str]"}, {"fullname": "environment.city.CityEnvironment.occupancy", "modulename": "environment.city", "qualname": "CityEnvironment.occupancy", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.city.CityEnvironment.event_manager", "modulename": "environment.city", "qualname": "CityEnvironment.event_manager", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.city.CityEnvironment.metrics", "modulename": "environment.city", "qualname": "CityEnvironment.metrics", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.city.CityEnvironment.neighbors", "modulename": "environment.city", "qualname": "CityEnvironment.neighbors", "kind": "function", "doc": "<p>Get the neighbors of a given node in the grid.</p>\n\n<p>Args:\n    node: Node coordinate (x, y).</p>\n\n<p>Returns:\n    List of adjacent node coordinates.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.city.CityEnvironment.get_drivable_edges", "modulename": "environment.city", "qualname": "CityEnvironment.get_drivable_edges", "kind": "function", "doc": "<p>Return all edges that can be used by vehicles.</p>\n\n<p>At the moment this is simply the full edge set of the grid.</p>\n\n<p>Returns:\n    List of edges as ((x1, y1), (x2, y2)).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.city.CityEnvironment.random_free_node", "modulename": "environment.city", "qualname": "CityEnvironment.random_free_node", "kind": "function", "doc": "<p>Pick a random node in the grid.</p>\n\n<p>This helper does not check congestion or incidents, so it is\nmainly used for choosing random vehicle goals.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.city.CityEnvironment.compute_avg_rho", "modulename": "environment.city", "qualname": "CityEnvironment.compute_avg_rho", "kind": "function", "doc": "<p>Compute the average congestion (rho) across all edges.</p>\n\n<p>Returns:\n    Average occupancy value across edges, or None if no\n    occupancy information is available.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.city.CityEnvironment.update_edge_weights", "modulename": "environment.city", "qualname": "CityEnvironment.update_edge_weights", "kind": "function", "doc": "<p>Update edge weights based on current congestion.</p>\n\n<p>The Occupancy object keeps a \"density\" estimate for every edge.\nThis method writes that value into the graph's \"weight\" field,\nwhich is then used by the routing algorithms (A*).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.city.CityEnvironment.random_roadblocks_loop", "modulename": "environment.city", "qualname": "CityEnvironment.random_roadblocks_loop", "kind": "function", "doc": "<p>Periodically spawn and clear temporary roadblocks.</p>\n\n<p>This coroutine runs forever (until the simulation exits) and\nuses the EventManager to create high-severity incidents on\nrandom edges that are not currently blocked.</p>\n\n<p>Args:\n    interval:\n        Time in seconds between iterations of the loop.\n    ttl:\n        Time-to-live in seconds for each spawned roadblock.\n    max_blocks:\n        Maximum number of new blocks to spawn per iteration.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">interval</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">3.0</span>,</span><span class=\"param\">\t<span class=\"n\">ttl</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">8.0</span>,</span><span class=\"param\">\t<span class=\"n\">max_blocks</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "async def"}, {"fullname": "environment.events", "modulename": "environment.events", "kind": "module", "doc": "<p>events.py</p>\n\n<p>Local incident / roadblock management for the grid environment.</p>\n\n<p>This module defines:</p>\n\n<ul>\n<li>Incident: dataclass that represents a temporary event on an edge.</li>\n<li>EventManager: keeps track of all active incidents and exposes helpers\nto query blocked edges / nodes and penalties for routing.</li>\n</ul>\n"}, {"fullname": "environment.events.Incident", "modulename": "environment.events", "qualname": "Incident", "kind": "class", "doc": "<p>Represent a single incident (e.g. accident / roadblock) on an edge.</p>\n\n<p>Attributes:\n    edge:   Normalized edge as a pair of nodes ((x1, y1), (x2, y2)).\n    severity:\n        Positive value that encodes how \"bad\" the incident is.\n        Large values typically mean the edge should be avoided.\n    ttl:\n        Time-to-live in seconds. After this time passes, the incident\n        is automatically removed.\n    created_at:\n        Wall-clock time when the incident was created.\n    expires_at:\n        Wall-clock time when the incident should be considered expired.</p>\n"}, {"fullname": "environment.events.Incident.__init__", "modulename": "environment.events", "qualname": "Incident.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">edge</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span>,</span><span class=\"param\">\t<span class=\"n\">severity</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">ttl</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">30.0</span>,</span><span class=\"param\">\t<span class=\"n\">created_at</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">expires_at</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "environment.events.Incident.edge", "modulename": "environment.events", "qualname": "Incident.edge", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Tuple"}, {"fullname": "environment.events.Incident.severity", "modulename": "environment.events", "qualname": "Incident.severity", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "1.0"}, {"fullname": "environment.events.Incident.ttl", "modulename": "environment.events", "qualname": "Incident.ttl", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "30.0"}, {"fullname": "environment.events.Incident.created_at", "modulename": "environment.events", "qualname": "Incident.created_at", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float | None", "default_value": "None"}, {"fullname": "environment.events.Incident.expires_at", "modulename": "environment.events", "qualname": "Incident.expires_at", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float | None", "default_value": "None"}, {"fullname": "environment.events.Incident.is_active", "modulename": "environment.events", "qualname": "Incident.is_active", "kind": "function", "doc": "<p>Check if this incident is still active.</p>\n\n<p>Returns:\n    True if the current time is before the expiration time.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.events.EventManager", "modulename": "environment.events", "qualname": "EventManager", "kind": "class", "doc": "<p>Manage temporary incidents (roadblocks) on edges of the city graph.</p>\n\n<p>The manager:</p>\n\n<ul>\n<li>stores incidents keyed by normalized edges;</li>\n<li>automatically removes expired incidents;</li>\n<li>exposes convenience methods for:\n<ul>\n<li>checking if an edge is blocked;</li>\n<li>providing a penalty value for routing;</li>\n<li>enumerating blocked edges and their endpoints.</li>\n</ul></li>\n</ul>\n"}, {"fullname": "environment.events.EventManager.incidents", "modulename": "environment.events", "qualname": "EventManager.incidents", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Dict[Tuple, environment.events.Incident]"}, {"fullname": "environment.events.EventManager.clear_expired", "modulename": "environment.events", "qualname": "EventManager.clear_expired", "kind": "function", "doc": "<p>Remove incidents whose TTL has passed.</p>\n\n<p>This method is called by most public helpers before returning\ninformation, so the map stays clean over time.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.events.EventManager.spawn_incident", "modulename": "environment.events", "qualname": "EventManager.spawn_incident", "kind": "function", "doc": "<p>Create or refresh an incident on a given edge.</p>\n\n<p>If an incident on that edge already exists and is active, its\nseverity and expiration time are updated instead of creating\na new object.</p>\n\n<p>Args:\n    edge:     Edge where the incident occurs.\n    severity: Intensity / importance of the incident.\n    ttl:      Time-to-live in seconds.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">edge</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span>, </span><span class=\"param\"><span class=\"n\">severity</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">ttl</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">30.0</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.events.EventManager.spawn_temporary_block", "modulename": "environment.events", "qualname": "EventManager.spawn_temporary_block", "kind": "function", "doc": "<p>Convenience: spawn a very severe incident on an edge.</p>\n\n<p>This is used by the random roadblock generator to create edges\nthat should be treated as fully blocked for a short period.</p>\n\n<p>Args:\n    edge: Edge to temporarily block.\n    ttl:  Time-to-live in seconds for this block.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">edge</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span>, </span><span class=\"param\"><span class=\"n\">ttl</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">8.0</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.events.EventManager.is_blocked", "modulename": "environment.events", "qualname": "EventManager.is_blocked", "kind": "function", "doc": "<p>Check if an edge should be considered blocked.</p>\n\n<p>Args:\n    edge:      Edge to query.\n    threshold: Minimum severity to count as \"blocked\".</p>\n\n<p>Returns:\n    True if there is an incident on the edge with severity\n    greater or equal to the given threshold.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">edge</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">3.0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.events.EventManager.penalty", "modulename": "environment.events", "qualname": "EventManager.penalty", "kind": "function", "doc": "<p>Get an extra routing cost for a given edge.</p>\n\n<p>Args:\n    edge: Edge to query.</p>\n\n<p>Returns:\n    A positive penalty based on severity if an incident exists,\n    or 0.0 if the edge is clear.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">edge</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.events.EventManager.blocked_edges", "modulename": "environment.events", "qualname": "EventManager.blocked_edges", "kind": "function", "doc": "<p>Return a list of edges that should be drawn as blocked.</p>\n\n<p>Args:\n    threshold: Minimum severity to be considered blocked.</p>\n\n<p>Returns:\n    A list of normalized edges with severity above the threshold.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">3.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.events.EventManager.blocked_nodes", "modulename": "environment.events", "qualname": "EventManager.blocked_nodes", "kind": "function", "doc": "<p>Return the set of nodes that belong to any blocked edge.</p>\n\n<p>This is mostly used by the visualizer to plot roadblock icons\nat the endpoints of blocked edges.</p>\n\n<p>Returns:\n    List of node coordinate tuples.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.occupancy", "modulename": "environment.occupancy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "environment.occupancy.Occupancy", "modulename": "environment.occupancy", "qualname": "Occupancy", "kind": "class", "doc": "<p>Tracks traffic occupancy and congestion levels across the city graph.</p>\n\n<p>This module maintains:\n  \u2022 Which vehicles are present on each edge.\n  \u2022 Edge capacities and \u201cfullness\u201d.\n  \u2022 Smoothed density values (Exponential Moving Average).\n  \u2022 Local congestion estimation around a node.</p>\n\n<p>It is used by routing agents to avoid congested edges and to compute\ndynamic path costs during A* navigation.</p>\n"}, {"fullname": "environment.occupancy.Occupancy.__init__", "modulename": "environment.occupancy", "qualname": "Occupancy.__init__", "kind": "function", "doc": "<p>Initialize the occupancy manager.</p>\n\n<p>Args:\n    city_graph (nx.Graph):\n        The city road graph. Nodes are intersections; edges are roads.\n    default_capacity (int):\n        Default max number of vehicles per edge before it is considered full.\n    alpha (float):\n        Smoothing factor for the Exponential Moving Average (0 to 1).\n        Larger values make density react faster to instantaneous changes.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">city_graph</span><span class=\"p\">:</span> <span class=\"n\">networkx</span><span class=\"o\">.</span><span class=\"n\">classes</span><span class=\"o\">.</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">Graph</span>,</span><span class=\"param\">\t<span class=\"n\">default_capacity</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.3</span></span>)</span>"}, {"fullname": "environment.occupancy.Occupancy.G", "modulename": "environment.occupancy", "qualname": "Occupancy.G", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.occupancy.Occupancy.road_usage", "modulename": "environment.occupancy", "qualname": "Occupancy.road_usage", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Dict[Tuple, Set[str]]"}, {"fullname": "environment.occupancy.Occupancy.capacity", "modulename": "environment.occupancy", "qualname": "Occupancy.capacity", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Dict[Tuple, int]"}, {"fullname": "environment.occupancy.Occupancy.smoothed_density", "modulename": "environment.occupancy", "qualname": "Occupancy.smoothed_density", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Dict[Tuple, float]"}, {"fullname": "environment.occupancy.Occupancy.alpha", "modulename": "environment.occupancy", "qualname": "Occupancy.alpha", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.occupancy.Occupancy.set_capacity", "modulename": "environment.occupancy", "qualname": "Occupancy.set_capacity", "kind": "function", "doc": "<p>Set a custom capacity for edge (u, v).</p>\n\n<p>Args:\n    u (tuple): First node of the edge.\n    v (tuple): Second node of the edge.\n    cap (int): Maximum number of vehicles allowed on that edge.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">cap</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.occupancy.Occupancy.enter", "modulename": "environment.occupancy", "qualname": "Occupancy.enter", "kind": "function", "doc": "<p>Register a vehicle entering edge (u, v).</p>\n\n<p>Args:\n    u (tuple): Previous node.\n    v (tuple): Next node.\n    vehicle_id (str): Vehicle identifier.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">vehicle_id</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.occupancy.Occupancy.leave", "modulename": "environment.occupancy", "qualname": "Occupancy.leave", "kind": "function", "doc": "<p>Register a vehicle leaving edge (u, v).</p>\n\n<p>Args:\n    u (tuple): Previous node.\n    v (tuple): Next node.\n    vehicle_id (str): Vehicle identifier.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">vehicle_id</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.occupancy.Occupancy.rho", "modulename": "environment.occupancy", "qualname": "Occupancy.rho", "kind": "function", "doc": "<p>Return smoothed traffic density (EMA) for the edge.</p>\n\n<p>This updates the exponential moving average every time it is called.</p>\n\n<p>Args:\n    edge (tuple): Edge (u, v).</p>\n\n<p>Returns:\n    float: Smoothed density value (0 to 1).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">edge</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.occupancy.Occupancy.is_full", "modulename": "environment.occupancy", "qualname": "Occupancy.is_full", "kind": "function", "doc": "<p>Check if the edge is considered congested.</p>\n\n<p>Args:\n    edge (tuple): The edge to check.\n    threshold (float):\n        Density threshold above which the edge is considered full.</p>\n\n<p>Returns:\n    bool: True if edge density &gt;= threshold.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">edge</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.9</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.occupancy.Occupancy.local_density", "modulename": "environment.occupancy", "qualname": "Occupancy.local_density", "kind": "function", "doc": "<p>Estimate congestion around a location.</p>\n\n<p>Args:\n    position (tuple): Node coordinates (x, y).\n    radius (int):\n        Graph-distance radius within which nearby edges are averaged.</p>\n\n<p>Returns:\n    float: Average smoothed density of neighboring edges.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">position</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">radius</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "environment.visualization", "modulename": "environment.visualization", "kind": "module", "doc": "<p>Visualization module for the Smart Traffic Simulation.</p>\n\n<p>This component is responsible for live rendering of the simulation using\nMatplotlib. It displays:\n  \u2022 road network grid\n  \u2022 vehicles\n  \u2022 emergency vehicles\n  \u2022 traffic lights\n  \u2022 hospitals\n  \u2022 incidents (blocked edges)</p>\n\n<p>The visualizer runs asynchronously, refreshing at a configurable frequency,\npulling data from the shared state dictionary updated by all SPADE agents.</p>\n"}, {"fullname": "environment.visualization.HandlerImage", "modulename": "environment.visualization", "qualname": "HandlerImage", "kind": "class", "doc": "<p>Custom legend handler that displays an image instead of a text marker.</p>\n\n<p>Attributes:\n    img (ndarray): Loaded image to display.\n    zoom (float): Scale factor applied when embedding the image.</p>\n", "bases": "matplotlib.legend_handler.HandlerBase"}, {"fullname": "environment.visualization.HandlerImage.__init__", "modulename": "environment.visualization", "qualname": "HandlerImage.__init__", "kind": "function", "doc": "<h2 id=\"parameters\">Parameters</h2>\n\n<p>xpad : float, optional\n    Padding in x-direction.\nypad : float, optional\n    Padding in y-direction.\nupdate_func : callable, optional\n    Function for updating the legend handler properties from another\n    legend handler, used by <code>~HandlerBase.update_prop</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img</span>, </span><span class=\"param\"><span class=\"n\">zoom</span><span class=\"o\">=</span><span class=\"mf\">0.03</span></span>)</span>"}, {"fullname": "environment.visualization.HandlerImage.img", "modulename": "environment.visualization", "qualname": "HandlerImage.img", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.visualization.HandlerImage.zoom", "modulename": "environment.visualization", "qualname": "HandlerImage.zoom", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.visualization.HandlerImage.create_artists", "modulename": "environment.visualization", "qualname": "HandlerImage.create_artists", "kind": "function", "doc": "<p>Creates the artist elements used inside the legend.</p>\n\n<p>Returns:\n    list: A list containing one AnnotationBbox with the scaled image.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">legend</span>,</span><span class=\"param\">\t<span class=\"n\">orig_handle</span>,</span><span class=\"param\">\t<span class=\"n\">xdescent</span>,</span><span class=\"param\">\t<span class=\"n\">ydescent</span>,</span><span class=\"param\">\t<span class=\"n\">width</span>,</span><span class=\"param\">\t<span class=\"n\">height</span>,</span><span class=\"param\">\t<span class=\"n\">fontsize</span>,</span><span class=\"param\">\t<span class=\"n\">trans</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "environment.visualization.Visualizer", "modulename": "environment.visualization", "qualname": "Visualizer", "kind": "class", "doc": "<p>Live visualization engine that renders the simulation environment.</p>\n\n<p>The Visualizer:\n  \u2022 loads sprites from /environment/assets/\n  \u2022 draws the static grid once\n  \u2022 periodically refreshes positions of vehicles, ambulances, lights\n  \u2022 renders incidents as edge markers\n  \u2022 runs as an async loop in parallel with SPADE agents</p>\n\n<p>Attributes:\n    city (CityEnvironment): The environment containing graph and assets.\n    shared (dict): Shared dictionary updated by agents with their positions.\n    refresh (int): Refresh rate (Hz).\n    period (float): Time per frame (s).\n    fig, ax: Matplotlib figure and axes used for rendering.</p>\n"}, {"fullname": "environment.visualization.Visualizer.__init__", "modulename": "environment.visualization", "qualname": "Visualizer.__init__", "kind": "function", "doc": "<p>Initialize the visualization engine.</p>\n\n<p>Args:\n    city (CityEnvironment): The grid and objects to draw.\n    shared_state (dict): Real-time positions (vehicles, emergency, lights).\n    refresh_hz (int): How many times per second to refresh.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">city</span>, </span><span class=\"param\"><span class=\"n\">shared_state</span>, </span><span class=\"param\"><span class=\"n\">refresh_hz</span><span class=\"o\">=</span><span class=\"mi\">5</span></span>)</span>"}, {"fullname": "environment.visualization.Visualizer.city", "modulename": "environment.visualization", "qualname": "Visualizer.city", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.visualization.Visualizer.shared", "modulename": "environment.visualization", "qualname": "Visualizer.shared", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.visualization.Visualizer.refresh", "modulename": "environment.visualization", "qualname": "Visualizer.refresh", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.visualization.Visualizer.period", "modulename": "environment.visualization", "qualname": "Visualizer.period", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.visualization.Visualizer.car_img", "modulename": "environment.visualization", "qualname": "Visualizer.car_img", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.visualization.Visualizer.ev_img", "modulename": "environment.visualization", "qualname": "Visualizer.ev_img", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.visualization.Visualizer.hospital_img", "modulename": "environment.visualization", "qualname": "Visualizer.hospital_img", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.visualization.Visualizer.light_img", "modulename": "environment.visualization", "qualname": "Visualizer.light_img", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.visualization.Visualizer.roadblock_img", "modulename": "environment.visualization", "qualname": "Visualizer.roadblock_img", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "environment.visualization.Visualizer.update_loop", "modulename": "environment.visualization", "qualname": "Visualizer.update_loop", "kind": "function", "doc": "<p>Asynchronous refresh loop that updates the visual state continuously.</p>\n\n<p>This method:\n    \u2022 calls <code>_update()</code> once per refresh period\n    \u2022 redraws only dynamic elements\n    \u2022 keeps the Matplotlib window alive without blocking SPADE</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "utils", "modulename": "utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utils.metrics", "modulename": "utils.metrics", "kind": "module", "doc": "<p>Metrics collection and plotting utilities for the MAS traffic simulation.</p>\n\n<p>This module provides:\n    - Recording of trip times for vehicles.\n    - Recording of emergency response durations.\n    - Optional logging of congestion snapshots (rho).\n    - Counting of route replanning events.\n    - Saving metrics to CSV.\n    - Generating histograms and time-series plots for analysis.</p>\n"}, {"fullname": "utils.metrics.Metrics", "modulename": "utils.metrics", "qualname": "Metrics", "kind": "class", "doc": "<p>Collect and manage simulation metrics.</p>\n\n<p>The metrics tracked include:\n    - Travel time per vehicle.\n    - Emergency vehicle (EV) response time.\n    - Optional congestion snapshots.\n    - Count of route replanning events.</p>\n\n<p>Attributes:\n    filename (str): Output CSV filename.\n    _trip_start (dict): Mapping vehicle_id \u2192 trip start timestamp.\n    _ev_start (float | None): Start timestamp of the active emergency.\n    records (list): Logged metric entries (dictionaries).\n    _rho_snapshots (list): Logged congestion values in [0, 1].\n    total_replans (int): Number of times an agent replanned its route.</p>\n"}, {"fullname": "utils.metrics.Metrics.__init__", "modulename": "utils.metrics", "qualname": "Metrics.__init__", "kind": "function", "doc": "<p>Initialise the metrics manager.</p>\n\n<p>Args:\n    filename (str, optional): Name of the CSV file where metrics will\n        be saved. Defaults to \"metrics.csv\".</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;metrics.csv&#39;</span></span>)</span>"}, {"fullname": "utils.metrics.Metrics.filename", "modulename": "utils.metrics", "qualname": "Metrics.filename", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "utils.metrics.Metrics.records", "modulename": "utils.metrics", "qualname": "Metrics.records", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "utils.metrics.Metrics.total_replans", "modulename": "utils.metrics", "qualname": "Metrics.total_replans", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "utils.metrics.Metrics.start_trip", "modulename": "utils.metrics", "qualname": "Metrics.start_trip", "kind": "function", "doc": "<p>Mark the start of a vehicle trip.</p>\n\n<p>Args:\n    vehicle_id (str): Identifier of the vehicle starting a trip.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">vehicle_id</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.metrics.Metrics.end_trip", "modulename": "utils.metrics", "qualname": "Metrics.end_trip", "kind": "function", "doc": "<p>Mark the end of a trip and record its duration.</p>\n\n<p>Args:\n    vehicle_id (str): Identifier of the vehicle that completed a trip.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">vehicle_id</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.metrics.Metrics.start_emergency", "modulename": "utils.metrics", "qualname": "Metrics.start_emergency", "kind": "function", "doc": "<p>Mark the beginning of an emergency response.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.metrics.Metrics.end_emergency", "modulename": "utils.metrics", "qualname": "Metrics.end_emergency", "kind": "function", "doc": "<p>Mark the end of an emergency response and record the duration.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.metrics.Metrics.log_congestion", "modulename": "utils.metrics", "qualname": "Metrics.log_congestion", "kind": "function", "doc": "<p>Log a congestion snapshot.</p>\n\n<p>Args:\n    avg_rho (float): Average congestion value in [0, 1].</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">avg_rho</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.metrics.Metrics.log_replan", "modulename": "utils.metrics", "qualname": "Metrics.log_replan", "kind": "function", "doc": "<p>Record a route replanning event.</p>\n\n<p>This method is called by:\n    - VehicleAgent._plan_to(...)\n    - EmergencyVehicleAgent._plan_to(...)</p>\n\n<p>Args:\n    vehicle_id (str): ID of the agent that replanned.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">vehicle_id</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.metrics.Metrics.save", "modulename": "utils.metrics", "qualname": "Metrics.save", "kind": "function", "doc": "<p>Write all metrics to a CSV file.</p>\n\n<p>The CSV contains rows of the form:\n    type, id, value</p>\n\n<p>Example rows:\n    trip, veh3, 17.42\n    ev_response, EV, 12.08\n    avg_rho, -, 0.03</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.metrics.Metrics.avg_trip_time", "modulename": "utils.metrics", "qualname": "Metrics.avg_trip_time", "kind": "function", "doc": "<p>Return the average trip duration.</p>\n\n<p>Returns:\n    float | None: Mean of all trip durations, or None if no trips exist.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utils.metrics.Metrics.last_ev_response", "modulename": "utils.metrics", "qualname": "Metrics.last_ev_response", "kind": "function", "doc": "<p>Return the most recent emergency response time.</p>\n\n<p>Returns:\n    float | None: Duration of last emergency response, or None if none exist.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utils.metrics.Metrics.avg_rho", "modulename": "utils.metrics", "qualname": "Metrics.avg_rho", "kind": "function", "doc": "<p>Return the mean congestion value.</p>\n\n<p>Returns:\n    float | None: Average congestion, or None if no snapshots exist.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utils.metrics.Metrics.summary", "modulename": "utils.metrics", "qualname": "Metrics.summary", "kind": "function", "doc": "<p>Return a compact summary of all metrics.</p>\n\n<p>Returns:\n    dict: Contains average trip time, emergency response time,\n        mean congestion, number of trips logged, and total replans.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.metrics.Metrics.save_plots", "modulename": "utils.metrics", "qualname": "Metrics.save_plots", "kind": "function", "doc": "<p>Generate PNG plots for trips, emergency responses and congestion.</p>\n\n<p>The following files are produced (depending on available data):\n    <base>_trip_hist.png\n    <base>_trip_series.png\n    <base>_ev_hist.png\n    <base>_ev_series.png\n    <base>_rho_series.png</p>\n\n<p>Args:\n    prefix (str | None, optional): Custom filename prefix. If None,\n        the prefix is derived from the CSV filename (without extension).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utils.routing", "modulename": "utils.routing", "kind": "module", "doc": "<p>Routing helpers for the multi-agent traffic management project.</p>\n\n<p>This module provides:</p>\n\n<ul>\n<li>A generic implementation of A* / Weighted A* with time-aware edge costs.</li>\n<li>Helper functions to compute routes that integrate city, events and occupancy.</li>\n<li>A utility to find the nearest traffic light based on Manhattan distance.</li>\n</ul>\n"}, {"fullname": "utils.routing.Node", "modulename": "utils.routing", "qualname": "Node", "kind": "variable", "doc": "<p></p>\n", "default_value": "typing.Tuple[int, int]"}, {"fullname": "utils.routing.nearest_traffic_light", "modulename": "utils.routing", "qualname": "nearest_traffic_light", "kind": "function", "doc": "<p>Return the JID of the nearest traffic light based on Manhattan distance.</p>\n\n<p>The function searches over the global TRAFFIC_LIGHTS dictionary, which is\nexpected to map traffic light JIDs to their grid positions. If no traffic\nlights are registered, it returns None.</p>\n\n<p>Args:\n    pos (Node): Current position of the agent in grid coordinates (x, y).</p>\n\n<p>Returns:\n    Optional[str]: JID of the nearest traffic light, or None if there are\n        no traffic lights available.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pos</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.routing.manhattan", "modulename": "utils.routing", "qualname": "manhattan", "kind": "function", "doc": "<p>Compute the Manhattan distance between two grid nodes.</p>\n\n<p>This heuristic is admissible on grid graphs where movement is restricted\nto horizontal and vertical directions.</p>\n\n<p>Args:\n    a (Node): First node (x, y).\n    b (Node): Second node (x, y).</p>\n\n<p>Returns:\n    float: Manhattan distance |dx| + |dy| between the two nodes.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.routing.astar", "modulename": "utils.routing", "qualname": "astar", "kind": "function", "doc": "<p>Run A* / Weighted A* search on an abstract graph.</p>\n\n<p>This function implements a generic A* (or Weighted A*) algorithm that:</p>\n\n<ul>\n<li>Uses a user-provided neighbor function.</li>\n<li>Supports time-aware edge costs via <code>edge_cost_fn</code>.</li>\n<li>Optionally skips forbidden edges (e.g., blocked or over capacity).</li>\n<li>Allows heuristic weighting (Weighted A*: f = g + w * h).</li>\n</ul>\n\n<p>Args:\n    start (Node): Start node.\n    goal (Node): Goal node.\n    neighbors_fn (Callable[[Node], List[Node]]): Function that returns\n        the list of neighbors for a given node.\n    edge_cost_fn (Callable[[Node, Node, int], float]): Function that\n        computes the cost of traversing an edge (u, v) at a given\n        estimated arrival tick.\n    heuristic_fn (Callable[[Node, Node], float], optional): Heuristic\n        function h(n, goal). Defaults to <code>manhattan</code>.\n    is_forbidden_fn (Callable[[Node, Node], bool], optional): Predicate\n        that returns True if an edge (u, v) should not be traversed\n        (for example due to incidents or capacity constraints).\n        Defaults to None (no edges forbidden).\n    weight (float, optional): Heuristic weight. A value of 1.0 yields\n        standard A<em>. Values greater than 1.0 correspond to Weighted A</em>,\n        which is faster but can produce suboptimal paths. Defaults to 1.0.\n    start_tick (int, optional): Simulation tick at which the search\n        starts. Used to compute time-dependent costs. Defaults to 0.\n    eta_per_edge (int, optional): Estimated number of ticks required to\n        traverse a single edge. Defaults to 1.</p>\n\n<p>Returns:\n    Optional[List[Node]]: Path as a list of nodes from start to goal,\n    or None if no path exists.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">goal</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">neighbors_fn</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]],</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">edge_cost_fn</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">heuristic_fn</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]],</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">manhattan</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">is_forbidden_fn</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]],</span> <span class=\"nb\">bool</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">weight</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">start_tick</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">eta_per_edge</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.routing.route_a_star", "modulename": "utils.routing", "qualname": "route_a_star", "kind": "function", "doc": "<p>Compute a route using (Weighted) A* with city, events and occupancy.</p>\n\n<p>This is a project-specific wrapper around <code>astar</code> that:</p>\n\n<ul>\n<li>Uses the city's neighbor function and base edge costs.</li>\n<li>Checks incident-based roadblocks via the events manager.</li>\n<li>Enforces capacity constraints via the occupancy module.</li>\n<li>Optionally accounts for time-dependent penalties on edges.</li>\n</ul>\n\n<p>Required City API:\n    - city.neighbors(node) -> List[Node]\n    - city.edge_cost(a, b) -> float\n    - (optional) city.time_penalty(a, b, tick) -> float</p>\n\n<p>Args:\n    city: City object providing graph neighbors and base edge costs.\n    events: Event manager used to detect blocked edges (incidents).\n    occupancy: Occupancy manager used to detect full edges.\n    start (Node): Start node for the route.\n    goal (Node): Goal node for the route.\n    weight (float, optional): Heuristic weight for A<em>/Weighted A</em>.\n        Typical values: 1.0 for exact A*, ~1.2 for faster approximate\n        routing. Defaults to 1.0.\n    start_tick (int, optional): Simulation tick at which the route\n        is being computed. Defaults to 0.\n    eta_per_edge (int, optional): Estimated ticks per edge, used to\n        compute arrival ticks in the cost function. Defaults to 1.\n    ignore_capacity (bool, optional): If True, capacity constraints from\n        <code>occupancy.is_full</code> are ignored (useful for emergency vehicles).\n        Defaults to False.</p>\n\n<p>Returns:\n    Optional[List[Node]]: List of nodes representing the route from\n    start to goal, or None if no feasible route exists.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">city</span>,</span><span class=\"param\">\t<span class=\"n\">events</span>,</span><span class=\"param\">\t<span class=\"n\">occupancy</span>,</span><span class=\"param\">\t<span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">goal</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">weight</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">start_tick</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">eta_per_edge</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">ignore_capacity</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.routing.route_weighted", "modulename": "utils.routing", "qualname": "route_weighted", "kind": "function", "doc": "<p>Compute a near-optimal route using Weighted A* (recommended for vehicles).</p>\n\n<p>This is a convenience wrapper around <code>route_a_star</code> configured for\nstandard vehicles. It uses a heuristic weight greater than 1.0 to\ntrade a small amount of optimality for faster search.</p>\n\n<p>Args:\n    city: City object providing graph neighbors and base edge costs.\n    events: Event manager used to detect blocked edges (incidents).\n    occupancy: Occupancy manager used to detect full edges.\n    start (Node): Start node for the route.\n    goal (Node): Goal node for the route.\n    start_tick (int, optional): Simulation tick at which the route\n        is being computed. Defaults to 0.\n    eta_per_edge (int, optional): Estimated ticks per edge. Defaults to 1.\n    weight (float, optional): Heuristic weight for Weighted A*. Defaults\n        to 1.2.</p>\n\n<p>Returns:\n    Optional[List[Node]]: Near-optimal path from start to goal, or None\n    if no feasible route exists.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">city</span>,</span><span class=\"param\">\t<span class=\"n\">events</span>,</span><span class=\"param\">\t<span class=\"n\">occupancy</span>,</span><span class=\"param\">\t<span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">goal</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">start_tick</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">eta_per_edge</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">weight</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.2</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.routing.route_exact", "modulename": "utils.routing", "qualname": "route_exact", "kind": "function", "doc": "<p>Compute an exact A* route (recommended for emergency vehicles).</p>\n\n<p>This wrapper calls <code>route_a_star</code> with weight=1.0, corresponding to\nstandard A*, and optionally ignores capacity constraints. It is\nsuitable for agents where obtaining the best possible route is\nmore important than search speed.</p>\n\n<p>Args:\n    city: City object providing graph neighbors and base edge costs.\n    events: Event manager used to detect blocked edges (incidents).\n    occupancy: Occupancy manager used to detect full edges.\n    start (Node): Start node for the route.\n    goal (Node): Goal node for the route.\n    start_tick (int, optional): Simulation tick at which the route\n        is being computed. Defaults to 0.\n    eta_per_edge (int, optional): Estimated ticks per edge. Defaults to 1.\n    ignore_capacity (bool, optional): If True, edges considered \"full\"\n        by the occupancy manager may still be used. This is typically\n        useful for emergency vehicles. Defaults to False.</p>\n\n<p>Returns:\n    Optional[List[Node]]: Path from start to goal, or None if no feasible\n    route exists.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">city</span>,</span><span class=\"param\">\t<span class=\"n\">events</span>,</span><span class=\"param\">\t<span class=\"n\">occupancy</span>,</span><span class=\"param\">\t<span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">goal</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">start_tick</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">eta_per_edge</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">ignore_capacity</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "main", "modulename": "main", "kind": "module", "doc": "<p>Main entry point for the Smart Traffic Management simulation.</p>\n\n<p>This module initializes the city environment, spawns all autonomous agents\n(vehicles, ambulances, traffic lights, and the incident reporter), launches\nthe live visualizer, and starts the simulation event loop.</p>\n\n<p>The simulation runs asynchronously using SPADE agents and monitors:\n    - normal vehicle movement\n    - emergency vehicle response\n    - traffic light coordination using Contract-Net\n    - dynamic roadblock generation and event propagation\n    - congestion monitoring\n    - metric collection and plot generation</p>\n\n<p>The program terminates only when manually stopped.</p>\n"}, {"fullname": "main.main", "modulename": "main", "qualname": "main", "kind": "function", "doc": "<p>Launches and manages the full simulation lifecycle.</p>\n\n<p>Responsibilities:\n    - Initialize Metrics, CityEnvironment, and shared state\n    - Create and start SPADE agents (vehicles, emergency vehicles,\n      traffic lights, incident reporter)\n    - Launch the visualizer update loop\n    - Start a background process that injects random roadblocks\n    - Continuously log global congestion (rho)\n    - Save metrics and plots when the simulation ends</p>\n\n<p>This function blocks indefinitely in the main loop until the program\nis terminated externally.</p>\n\n<p>Raises:\n    asyncio.CancelledError: If the main loop is cancelled by shutdown.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();